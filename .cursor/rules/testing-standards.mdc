---
description: Testing practices to follow for Sanity plugin development
alwaysApply: false
---

# Testing Standards and TypeScript Strict Mode

## Testing Infrastructure

### Test Setup Requirements
- Use Vitest as the test runner
- Use React Testing Library for component testing
- Use `@testing-library/jest-dom` for additional matchers
- Mock Sanity client calls appropriately
- Set up test environment with proper DOM simulation

### Test File Organization
- Place test files alongside source files with `.test.ts` or `.test.tsx` extension
- Use descriptive test names that explain the expected behavior
- Group related tests using `describe` blocks
- Use `it` or `test` for individual test cases

### Testing Patterns

#### Component Testing
```typescript
import {render, screen} from '@testing-library/react'
import {describe, it, expect} from 'vitest'
import {ComponentName} from './ComponentName'

describe('ComponentName', () => {
  it('should render correctly with valid props', () => {
    render(<ComponentName prop1="value" />)
    expect(screen.getByText('expected text')).toBeInTheDocument()
  })
  
  it('should handle user interactions', async () => {
    render(<ComponentName prop1="value" />)
    const button = screen.getByRole('button')
    await userEvent.click(button)
    // Assert expected behavior
  })
})
```

#### Utility Function Testing
```typescript
import {describe, it, expect} from 'vitest'
import {utilityFunction} from './utilityFunction'

describe('utilityFunction', () => {
  it('should return expected result for valid input', () => {
    const result = utilityFunction('valid input')
    expect(result).toBe('expected output')
  })
  
  it('should handle edge cases', () => {
    const result = utilityFunction('')
    expect(result).toBe('default output')
  })
})
```

#### Sanity Client Mocking
```typescript
import {createMockClient} from './test-utils'

const mockClient = createMockClient({
  // Mock specific client methods
  fetch: vi.fn().mockResolvedValue({data: []}),
  listen: vi.fn().mockReturnValue({subscribe: vi.fn()})
})
```

### Test Coverage Requirements
- Aim for 80%+ code coverage
- Test all public functions and components
- Test both success and error scenarios
- Test edge cases and boundary conditions
- Mock external dependencies appropriately

## TypeScript Strict Mode Guidelines

### Strict Mode Requirements
- Always use TypeScript strict mode
- Avoid `any` types - use specific interfaces or `unknown`
- Use proper type annotations for all function parameters and return values
- Leverage Sanity's type generation tools where possible
- Use `@sanity/types` for base types

### Type Safety Patterns

#### Interface Definitions
```typescript
interface ComponentProps {
  requiredProp: string
  optionalProp?: number
  callbackProp: (value: string) => void
}
```

#### Generic Types
```typescript
function createWrapper<T>(Component: React.ComponentType<T>, props: T) {
  return <Component {...props} />
}
```

#### Type Guards
```typescript
function isConceptScheme(obj: unknown): obj is ConceptScheme {
  return typeof obj === 'object' && obj !== null && 'name' in obj
}
```

### Sanity-Specific Types
- Use `SanityDocument` for document types
- Use `SanityReference` for reference fields
- Use `SanityImage` for image fields
- Create specific interfaces for plugin functionality

## Code Quality Standards

### ESLint Configuration
- Use strict TypeScript rules
- Enable React hooks rules
- Include accessibility linting rules
- Configure import/export rules
- Use Prettier for code formatting

### Error Handling
- Use try-catch blocks for async operations
- Provide meaningful error messages
- Use proper error types and interfaces
- Handle edge cases gracefully

### Performance Considerations
- Use `React.memo()` for expensive components
- Use `useCallback()` and `useMemo()` appropriately
- Avoid unnecessary re-renders
- Optimize list rendering with proper keys

## Accessibility Requirements
- Use semantic HTML elements
- Include proper ARIA labels and roles
- Ensure keyboard navigation works
- Provide screen reader support
- Test with accessibility tools

## Documentation Standards
- Use JSDoc comments for all public functions and components
- Include parameter and return type documentation
- Provide usage examples for complex functions
- Document any non-obvious business logic